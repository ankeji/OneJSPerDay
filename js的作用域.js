/*
 * @Descripttion: 
 * @version: 
 * @Author: ankeji
 * @Date: 2020-10-21 17:22:05
 * @LastEditors: ankeji
 * @LastEditTime: 2020-10-21 18:12:34
 */
// 函数作用域 一个“{}”就是一个作用域
// ES6引入了块级作用域。块级作用域就是指变量在指定的代码块里面才能访问，也就是一对{}中可以访问，在外面无法访问。为了区分之前的var，块级作用域使用let和const声明，let申明变量，const申明常量。
function f() {
    let y = 1;
    if (true) {
        var x = 2; // 这是用var声明的，是函数作用域，可以被整个函数访问
        let y = 2; // 因为y是用let声明的，是块级作用域，只能被if里面进行访问
        console.log(y);
    }
    console.log(x);   // 2
    console.log(y);   // 1
}

f();



// let和const不具备变量提升
var x = 1;
if (true) {
    // console.log(x); //报错Identifier 'x' has already been declared
    let x = 2;
}
// 如果不具备变量提升的话，这里x打印的应该是1，但是这里面报错了，这就说明了是具有变量提升的




// 循环中的应用
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i)  // 输出3个3
    })
}
// 因为setTimeout是异步代码，会在下次事件循环执行，而i++却是同步代码，而全部执行完，等到setTimeout执行时，i++已经执行完了，此时i已经是3了


for (var i = 0; i < 3; i++) {
    (function (i) {
        setTimeout(() => {
            console.log(i)
        })
    })(i)
}
// 改成自执行函数：只要有i传进来，setTimeout就开始执行，这样for的同步执行，每次给setTimeout传值，setTimeout就会执行一次


// 另一种方式就是使用let声明
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i)
    })
}
// 这种写法也适用于for...in和for...of循环
// 使用const是不行的 ，因为const是不能赋值的，const创造就是用来声明常量的，不可改变的量，所以i++会报错



// let和const声明不会影响全局windows对象，var的变量提升会覆盖全局变量
// 例如:
var JSON = 'json';
console.log(window.JSON);   // JSON被覆盖了，输出'json'

// 而使用let申明变量则没有这个问题:
// 因为let和const申明的是块级作用域，不具有变量提升，不会影响全局变量


/**
总结：
    var是用来申明函数作用域的，let和const是用来声明块级作用域的，块级作用域只能被当前块访问，函数作用域可以被整个函数访问
    let 和 const 声明的块级作用域是不能被重复声明的
    let 可读可写，不能被重新定义
    const 可读不可写（用来声明常量的）

    相同点：
        都不能被重新定义
        都不具备变量提升，不会影响全局变量（不太准确）
    不同点：
        let ：可读可写
        const ：可读不可写


上面这么多点其实都是let和const对以前的var进行的改进，如果我们的开发环境支持ES6，我们就应该使用let和const，而不是var。
 */



//===================== 作用域链

/**
 * 作用域链其实是一个很简单的概念，当我们使用一个变量时，先在当前作用域查找，如果没找到就去他外层作用域查找，如果还没有，就再继续往外找，一直找到全局作用域，如果最终都没找到，就报错。
 */
let x = 1;

function f() {
    function f1() {
        console.log(x);
    }
    f1();
}
f();
// f1作用域 -> f作用域 -> 全局作用域

// 这段代码在f1中输出了x，所以他会在f1中查找这个变量，当然没找到，然后去f中找，还是没找到，再往上去全局作用域找，这下找到了。这个查找链条就是作用域链。


//暂时性死区

var tmp = 123;

if (true) {
   tmp = 'abc'; // ReferenceError
   let tmp;
}
// 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
// ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
// 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。


/**
 * 大总结
    1.作用域其实就是一个变量绑定的有效范围。
    2.JS使用的是静态作用域，即一个函数使用的变量如果没在自己里面，会去定义的地方查找，而不是去调用的地方查找。去调用的地方找到的是动态作用域。
    3.var变量会进行申明提前，在赋值前可以访问到这个变量，值是undefined。
    4.函数申明也会被提前，而且优先级比var高。
    5.使用var的函数表达式其实就是一个var变量，在赋值前调用相当于undefined()，会直接报错。
    6.let和const是块级作用域，有效范围是一对{}。
    7.同一个块级作用域里面不能重复申明，会报错。
    8.块级作用域也有“变量提升”，但是行为跟var不一样，块级作用域里面的“变量提升”会形成“暂时性死区”，在申明前访问会直接报错。
    9.使用let和const可以很方便的解决循环中异步调用参数不对的问题。
    10.let和const在全局作用域申明的变量不会成为全局对象的属性，var会。
    11.访问变量时，如果当前作用域没有，会一级一级往上找，一直到全局作用域，这就是作用域链。
    12.try...catch的catch块会延长作用域链，往最前面添加一个错误对象。
    13.with语句可以手动往作用域链最前面添加一个对象，但是严格模式下不可用。
    14.如果开发环境支持ES6，就应该使用let和const，不要用var。
 */
