/*
 * @Descripttion: 
 * @version: 
 * @Author: ankeji
 * @Date: 2020-10-21 18:26:43
 * @LastEditors: ankeji
 * @LastEditTime: 2020-10-22 09:19:47
 */
// JS中的数据类型主要分为两大类：原始类型(值类型)和引用类型。
undefined, null, Number, String, Boolean, Symbol  //原始数据类型
Object, Array, Function //引用数据类型
/**
 * 原始数据类型存在栈中，引用类型在栈中存的是一个引用地址，这个地址指向的是堆中的一个数据对象。需要注意的是null在这里我们算在原始类型里面，但是你用typeof的时候会发现他是object，原因是就算他是一个对象，那他应该在栈中存一个引用地址，但是他是一个空对象，所以这个地址为空，也就是不对应堆中的任意一个数据，他在堆中没有数据，只存在于栈中，所以这里算为了原始类型。引用类型其实主要就是Object，Array和Function这些其实也都是Object派生出来的
 */

// 1.原始类型的值无法更改，要更改只能重新赋值。像下面这样尝试去修改是不行的，但是整个重新赋值可以。
// 2.原始类型的比较就是比较值，值相等，他们就相等
// 3.引用类型的值是可以修改的，注意这个时候我们虽然修改了a里面的属性，但是a在栈上的引用地址并没有变化，变化的是堆中的数据
// 4.引用类型的比较是比较他们的索引地址，而不是他们的值。比如下面两个对象，看着是一样的，但是他们的引用地址不一样，其实是不等的


// 取时间戳的两种的方式
// 1.let a = new Date().getTime()
// 2.let a = +new Date()



// 下面的值在进行bool转换时会转换为false，除此以外都是true:

// 0
// NaN
// ''(空字符串)
// null
// undefined




// ==运算符
// 当我们使用==进行比较时，如果两边的类型不同，JS会进行类型转换，然后再比较，===则不会进行类型转换，如果===两边的数据类型不同，直接返回false。

// 例如
'0' == 0 , 0 == false//true
'0' === 0 //false

typeof //只能检测原始数据类型，没办法检测具体的对象类型
instanceof //无法检测原始数据类型，原理是原型链
constructor //检查的是原型链上的constructor，如果原型链被意外覆盖了，结果不准确
Duck-typing //通过特征来检测类型，可以被具有同样特征的对象欺骗，不可靠，只能用于特定场景
Object.prototype.toString //只能检测原生对象，不能检测自定义类型
原生方法  //使用很方便，但是目前原生方法还很少



// 总结：
// JS有两种数据类型，原始类型和引用类型，引用类型主要就是对象。
// 当我们使用+，逻辑判断或者==时会有隐式的类型转换。
// 有时候隐式的类型转换会出现我们不想要的结果，如果我们确定要进行判断或者类型转换，最好使用显式的，比如使用===，而不是==。
// 对象转为字符串和数值可能需要调valueOf和toString方法，调用顺序需要看具体场景。
// JS没有一个完美的类型检测方法，我们最好根据需要选择具体的检测方法。
